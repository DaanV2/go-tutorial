# Collect products

In this tutorial, we have to go over a list of clients and their receipts, collecting per client and in total how many items we are going to need.
But the list of orders are provided by multiple people in different formats.

In `data/receipts` you will find the receipts from the different people. in CSV and json format. A client can have bought the same product multiple times, so we have to count the quantity of the products.

## Start hints:

- There is a package called encoding/json that can be used to decode json data.
- There is also a package called encoding/csv that can be used to decode csv data.
- You can read files with the `os` package.
- You can collect files with the `os` package.
- You can get join folders with the `path` package.

## Walkthrough

### 0. Setup

We should already have a main.go and a cmd/root.go that has been created by cobra-cli. If not, please go back to the start tutorial.
Then we can create a new subcommand called `collect-products` in the `cmd/root.go` file.

```go
cobra-cli add collect-products
```

This will create a new subcommand in the `cmd` folder with a `collect-products.go` file in it.

```go
package cmd

import (
    "fmt"

    "github.com/spf13/cobra"
)

// collectProductsCmd represents the collectProducts command
var collectProductsCmd = &cobra.Command{
    Use:   "collect-products",
    Short: "Collect the products from the receipts",
    Run: func(cmd *cobra.Command, args []string) {
        fmt.Println("collectProducts called")
    },
}
```

Lets first move the Run function to a new function
    
```go
var collectProductsCmd = &cobra.Command{
    Use:   "collect-products",
    Short: "Collect the products from the receipts",
    Run: collectProducts,
}

func collectProducts(cmd *cobra.Command, args []string) {
    fmt.Println("collectProducts called")
}
```

###  1. Receipt format

If we look at the data in `data/receipts` we can see that the data is in different formats.

**CSV**
```csv
id,quantity,note,price,tax,time
2049cb74-a413-4e0e-ba88-08edf86ad809,2,41fed8d04548,11.901973411244565,1.723017722749384,2024-06-04T09:46:27+02:00
```

**JSON**
```json
{
    "items": [
        {
            "id": "2049cb74-a413-4e0e-ba88-08edf86ad809",
            "quantity": 2,
            "note": "41fed8d04548",
            "price": 11.901973411244565,
            "tax": 1.723017722749384,
            "time": "2024-06-04T09:46:27+02:00"
        }
    ]
}
```

From this data we can see that the data about the same.
So lets create a struct that can hold the data from the receipts.

```go
type Product struct {
    ID       string    `json:"id"`
    Quantity int       `json:"quantity"`
    Note     string    `json:"note"`
    Price    float64   `json:"price"`
    Tax      float64   `json:"tax"`
    Time     time.Time `json:"time"`
}

type Receipt struct {
    Items []Product `json:"items"`
}
```

Note the text after the types, Which is a field tag. This is used to tell the encoder/decoder where to find the data in the data. For example: `json:"id"` means that the `ID` field in the struct is stored in the `id` field in the json. The csv package doesn't use field tags, but uses the order of the fields in the struct.

### 2. Reading the data

Lets create seperate functions that can read the data from the different formats.

**CSV**
```go
import (
    "encoding/csv"
    "errors"
    "fmt"
)

func FromCSV(filepath string) (*Receipt, error) {
    file, err := os.Open(filepath)
    if err != nil {
        return nil, err
    }
    defer file.Close()

    r := csv.NewReader(file)
    receipt := &Receipt{}

    for {
        record, err := r.Read()
        // The reader will return an error if it's at the end of the file
        if errors.Is(err, io.EOF) {
            return receipt, nil
        }
        if err != nil {
            // This is a custom error message, with the original error as a cause
            // This is useful for debugging, as it will show the original error
            return nil, fmt.Errorf("failed to read record: %s: %w", record, err)
        }
        if len(record) < 6 {
            return nil, fmt.Errorf("not enough items in: %v", record)
        }

        item := Product{
            ID:   line[0],
            Note: line[2],
            Time: line[5],
        }
        
        var err error
        if item.Quantity, err = strconv.Atoi(line[1]); err != nil {
            return nil, fmt.Errorf("failed to parse quantity: %s: %w", line[1], err)
        }
        if item.Price, err = strconv.ParseFloat(line[3], 64); err != nil {
            return nil, fmt.Errorf("failed to parse price: %s: %w", line[3], err)
        }
        if item.Tax, err = strconv.ParseFloat(line[4], 64); err != nil {
            return nil, fmt.Errorf("failed to parse tax: %s: %w", line[4], err)
        }

        receipt.Items = append(receipt.Items, product)
    }

    return receipt, nil
}
```

**JSON**
```go
import (
    "encoding/json"
    "os"
)

func FromJSON(filepath string) (*Receipt, error) {
    file, err := os.Open(filepath)
    if err != nil {
        return nil, err
    }
    defer file.Close()

    receipt := &Receipt{}
    // Decode needs a pointer to the struct, so it can fill it with the data
    if err := json.NewDecoder(file).Decode(receipt); err != nil {
        return nil, err
    }

    return receipt, nil
}
```

Now we can create a function that can read the data from the different formats.

```go
func ReadReceipt(filepath string) (*Receipt, error) {
    switch ext := filepath.Ext(filepath); ext {
    case ".csv":
        return FromCSV(filepath)
    case ".json":
        return FromJSON(filepath)
    default:
        return nil, fmt.Errorf("unknown file extension: %s", ext)
    }
}
```

### 3. Collecting the data

Now that we can read the data, we can start collecting the data.
We create a function that walks over the client directories in `data/receipts` and reads their receipts.  

lets create a function that collects all receipts in the clients folder

```go
import (
    "os"
    "path/filepath"
)

func CollectReceipts(folder string) ([]*Receipt, error) {
    receipts := []*Receipt{}

    // Walk walks the file tree rooted at dir
    err := filepath.Walk(folder, func(filepath string, info os.FileInfo, err error) error {
        if err != nil {
            return err
        }
        if info.IsDir() {
            return nil
        }

        receipt, err := ReadReceipt(filepath)
        if err != nil {
            return fmt.Errorf("failed to read receipt: %s: %w", filepath, err)
        }
        receipts = append(receipts, receipt)

        return nil
    })

    return receipts, err
}
```

```go
type Client struct {
    ID     string
    Receipts []*Receipt
}

func CollectProducts() ([]*Client, error) {
    dir := path.Join("data", "receipts")
    clients := []*Client{}

    // Each dir is a client, with in those dirs all their receipts
    err := filepath.Walk(dir, func(clientFolder string, info os.FileInfo, err error) error {
        if err != nil {
            return err
        }
        if !info.IsDir() {
            return nil
        }

        client := &Client{
            ID: info.Name(),
        }
        clients = append(clients, client)

        receipts, err := CollectReceipts(clientFolder)
        if err != nil {
            return fmt.Errorf("failed to collect receipts: %s: %w", filepath, err)
        }
        client.Receipts = receipts

        return nil
    })

    return clients, err
}

```

### 4. Counting the items

A client can have bought the same product multiple times, so we have to count the quantity of the products. So we are going to create an object that stores the final result

```go
type Overview struct {
    ToBuy    map[string]int
}
```

Now we convert the collected clients in a total per client and in total.

```go

func (o *Overview) Add(receipt *Receipt) {
    for _, product := range receipt.Items {
        o.ToBuy[product.ID] += product.Quantity
    }
}

func (o *Overview) AddClient(client *Client) {
    for _, receipt := range client.Receipts {
        o.Add(receipt)
    }
}

total := &Overview{
    ToBuy: map[string]int{},
}
clientData := map[string]*Overview{}
clients := CollectProducts()

for _, client := range clients {
    clientOverview := &Overview{
        ToBuy: map[string]int{},
    }
    clientData[client.ID] = clientOverview

    total.AddClient(client)
    clientOverview.AddClient(client)
}
```

### 5. Printing the result

Now we can print the result

```go
func (o *Overview) Print(title string) {
    fmt.Println("====", title, "====")
    for id, quantity := range o.ToBuy {
        fmt.Printf("%s: %d\n", id, quantity)
    }
}

total.Print("Total")
for id, client := range clientData {
    client.Print("client " + id)
}
```*